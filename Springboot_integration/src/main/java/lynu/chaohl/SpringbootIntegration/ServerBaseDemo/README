Demo点：
***文件上传:
    (1):代码逻辑：将文件上传到项目的根目录下，将文件转成实例化属性并放入到缓存中，在保存实例的时候将路径存放到数据库中
    (2):详见：lynu.chaohl.SpringbootIntegration.ServerBaseDemo.controller.ServerBaseDemoController.uploadFile()

***本地缓存技术：Caffeine
    (1):详见：https://blog.csdn.net/w727655308/article/details/121623776

***mybatis-generator代码生成器，目前还有写问题需要优化，(1)重复生成会将mapper.xml在原文件里再生成一遍，导致代码重复,
如果一个项目中已经生成过一个实体类，使用此配置重复生成的的话，会造成代码重复，原因未明。
(2)如果不指定xml和Mapper的映射路径，那么使用默认的配置就不能瞎新增命名文件,mapper文件下必须是mapper文件，不能再新加目录，
resources下的文件目录需要一致。

***mybatis测试：(1)对应关系映射测试见../resources/mybatis/mapper/testMapper/NationMapper.xml
    (2):批量查询测试见：../resources/mybatis/mapper/testMapper/ServerBaseDemoMapper.xml
    (3):缓存：默认开启一级缓存，其依赖于sqlsession一级缓存也叫本地缓存，当和spring整合时，一级缓存会失效，因为其依赖的sqlsession
        会被spring自动关闭，导致一级缓存无效：与数据库同一次会话期间查询到的数据会放在本地缓存中。
        以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；
        备注：每个sqlSession中的缓存相互独立；sqlSession相同，两次查询之间执行了增删改操作；sqlSession相同，手动清除一级缓存；会导致缓存失效
        二级缓存需要手动开启：需要在mybaits.xml中增加开启配置。只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据，查出的数据都会被默认先放在一级缓存中
        只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中。

***分页：(1)使用sql的limit关键字做分页，详细见..mapper.ProvinceAddMapper

***spring中的静态代理和动态代理的区别，是静态还是动态是代理对象怎么生成的来区分，如果是代码写好的代理那么就是静态，如果有
类库proxy生成的代理对象那么就是动态代理。

